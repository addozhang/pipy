---
title: 03 代理
---

import FlagIcon from '@material-ui/icons/FlagSharp'
import SvgProxyPipelines from './proxy-pipelines.svg';

前面我们将 Pipy 作为服务器来处理请求。这次我们尝试其最常见的用法：网络代理。

## 创建 Pipy 程序

点击管理界面左上角的 Pipy Logo 就可以回到主界面。创建一个名为 `/proxy` 的代码库，方式参考 [01 Hello](/tutorial/01-hello#创建-pipy-程序)。

> 前面我们创建的 `/hello` 代码库请继续保留，后面我们会将其用作上游服务。

添加文件 `/proxy.js` 并点击 <FlagIcon/> 按钮将其设置为入口脚本：

```js
pipy()

.listen(8000)
  .demuxHTTP('forward')

.pipeline('forward')
  .muxHTTP('connection', '')

.pipeline('connection')
  .connect('localhost:8080')
```

### 代码剖析

除了端口管道以外，这次有两个的 *子管道（sub-pipeline）*：“*forward*”和“*connection*”。

1. 端口管道监听在 `8080` 端口，只包含了一个 **demuxHTTP** 过滤器。**demuxHTTP** 与 **serveHTTP** 有点类似，但与后者在*回调函数*中处理请求不同，前者在*子管道*中处理请求。*子管道*的名称“*forward*”作为其唯一构造参数来引用子管道。
2. “*forward*”子管道包含了一个 **muxHTTP** 过滤器。这个过滤器从 **demuxHTTP** 接收消息作为输入，紧接着转给另一个*子管道* “connection”。同样使用子管道的名称作为其构造参数。
3. 管道 “connection” 也是一个子管道。同样，只包含了一个过滤器 **connect**，“connect” 会将接收到的输入全部发送到构造参数（“*localhost:8080*”）指定的远程主机，并传输收到的所有内容。

## Mux 和 demux

可能你会问明明可以用 1 个管道就能解决的，为什么要用 3 个管道。这与 7 层协议（比如 HTTP）和 4 层协议的工作方式有关。

简单地说，在 4 层中看到的是“*流*”，而在 7 层中看到的是组成流的离散“*消息*”。

### demuxHTTP 过滤器

*端口管道*以 [Data](/reference/api/Data) 事件序列的方式接收进入的输入，每个 **Data** 事件携带小块的 TCP 流。**demuxHTTP** 将 TCP 流分隔成独立的 HTTP 消息，然后将它们封装成 [*MessageStart*](/reference/api/MessageStart) 和 [*MessageEnd*](/reference/api/MessageEnd) 事件做进一步的处理。

每个从 TCP 流中提取的消息都应该在独立的管道中处理，而不是工作在 TCP 层之上的 **demuxHTTP** 管道。在某些简单的场景下，在接受流的管道中处理并没有什么问题；但是你终归会因为在消息间混合状态而遇到逻辑错误。

**demuxHTTP** 就是被设计用来将消息发送到新的子管道处理的过滤器。每个从输入流中提取的消息就会这么操作。这就意味着端口管道处理入站的连接，在经过 **demuxHTTP** 后分流进入多个子管道中，来保证每个消息都被独立处理。

### muxHTTP 过滤器

在代理的例子中，我们需要将所有消息送到上游服务器。在 HTTP 消息可以发送之前，需要包装成 TCP 流。但是我们不能为每个转发的消息都做这种处理，这样会产生过多的流，从而导致过多的出站连接。

这里就需要用到 **muxHTTP**。它将多个输入流合并成一个 TCP 流，并注入到同一个管道中。最后那个管道中的 **connect* * 过滤器会建立一个到上游的 TCP 连接，然后往复地传输数据。

### 管道拓扑

比如一个入站连接上的两个请求，完成这些我们需要 4 个相互链接的管道：

<div style="text-align: center">
  <SvgProxyPipelines/>
</div>

## 测试

启动代理之后，执行：

```sh
curl localhost:8000 -i
```

将看到：

```
HTTP/1.1 502 Connection Refused
content-length: 0
connection: keep-alive
```

错误原因是我们没有上游服务来处理请求。

### 启动第二个 Pipy 实例

现在我们只有一个运行着代理程序的 Pipy 实例。现在我们需要另外一个实例来完成测试：

1. 返回管理的主界面并找到上次创建的 `/hello` 代码库，点击打开。
2. 复制浏览器地址栏中的地址，如 `http://localhost:6060/repo/hello/`， **注意最后的 `/` 不能去掉**。
3. 新开一个命令行窗口执行，然后执行下面的命令

```sh
pipy http://localhost:6060/repo/hello/
```

此时第二个实例应该启动。再次使用前面的命令测试，应该就能看到期望的结果了。

```
HTTP/1.1 200 OK
content-length: 11
connection: keep-alive

Hi, there!
```

## 总结

这次的教程中，你应该学会如何用 Pipy 实现网络代理了。同样了解了为什么需要 *子管道*以及为什么比入站的连接数还多。

### 收获

1. 端口管道在 TCP 层接收数据。处理独立的 HTTP 消息，我们需要使用 **serveHTTP** 或者 **demuxHTTP** 过滤器从 TCP 层分离消息。
2. **serveHTTP** 与 **demuxHTTP** 的区别是，前者在*回调*函数中处理抽取的消息，而后者在独立的子管道中处理。
3. 在将 HTTP 消息通过网络发送之前，需要使用 **muxHTTP** 组装成 TCP 流。
4. 使用 **connect** 与远程主机建立 TCP 连接。

### 接下来

我们初步在网络代理的尝试还是很简单的，只做了两个IP/端口间的映射。对于一个可用的网络代理来说，我们需要像路由、负载均衡等功能。

下一步，我们将尝试代理的基础功能：路由。