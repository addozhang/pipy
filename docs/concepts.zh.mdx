---
title: 概念
---

## 流

Pipy 是一个 “_流处理器_”，它将 *流* 作为输入和输出。但与人们通常认为的 _流_ 不同，Pipy 中的流是由 **事件（events）** 而不是单个数据字节组成。有四种类型的事件：

* `Data`
* `MessageStart`
* `MessageEnd`
* `StreamEnd`

来自网络的流仅由数据字节组成。它们以块的形式地出现。每个这样的块在 Pipy 中表示为 **Data** 事件。

Pipy 处理输入流中的事件：有些被转换，有些被丢弃，也有些新的事件加入。Pipy 内部那些新生成的事件还包含了除 **Data** 以外的类型： **MessageStart**、**MessageEnd** 和 **StreamEnd**。这些非数据事件作为 “_标记（markers）_” 使用，为承载业务逻辑的原始字节流提供更高级的语义。

最终，所有这些处理过的事件流被转换成原始数据字节回到网络。此时，除 **Data** 以外的所有其他事件都被丢弃。

## 过滤器和管道

了解管道（Pipeline）的最佳方法是将其想象成 [_Unix pipelines_](https://en.wikipedia.org/wiki/Pipeline_(Unix))。

Pipy 内部的 **过滤器（Filter）** 链处理处理传入的流。每个过滤器有点像一个小型 Unix 进程，从其输入（stdin）读取并将结果写到输出（stdout），一个过滤器的输出是下一个过滤器的输入。

过滤器链称作 **管道**。按其输入源的类型分成 3 类：

### 端口管道

**端口管道（Port pipeline）** 从网络端口读取并处理 **Data** 事件，然后将结果回写到同一个端口，是最常用的 **_请求响应模型_**。

例如，当 Pipy 用作 HTTP 服务器时，端口管道的输入是来自客户端的 HTTP 请求。管道的输出则是发回的 HTTP 响应。

### 定时器管道

**定时器管道（Timer Pipeline）** 定期得到一对 **MessageStart** 和 **MessageEnd** 事件作为其输入。不论内部的过滤器如何处理，都不会有任何输出。

这种类型的管道在类似 [Cron Job](https://en.wikipedia.org/wiki/Cron) 的任务场景很有用。

### 子管道

一个管道中的**联合过滤器（Sub-pipeline）** 可以将流传入**子管道**。最基本的联合过滤器是 **link**。它从管道中的前一个过滤器接收事件，将它们发送到子管道进行处理并获取来自该子管道的输出，然后将他们发送到下一个过滤器。

*子管道*和*联合过滤器*有点像程序设计里子程序调用过程中的*被调用方*和*调用方*。联合过滤器的输入是子程序的参数，联合过滤器的输出是它的返回值。

与子管道不同，其他类型的管道 **端口管道** 和 **定时器管道** 不能被联合过滤器 **_调用_**。换句话说，它们不能从内部启动，而是从外部启动。我们称这些管道为**起始管道（root pipelines）**。

## 上下文

**上下文（Context）** 是附加到管道的一组变量。每个管道在 Pipy 实例中都有相同的变量集。换句话说，上下文具有相同的*形态*。当启动 Pipy 实例时，要做的第一件事是定义上下文的*形态*，就是其拥有哪些变量以及变量的初始值。

每个起始管道“复制” Pipy 实例启动时定义的“原始的上下文”。当子管道启动时，它会*共享*或*复制*其父级的上下文，具体取决于所使用的联合过滤器。例如 *link* 过滤器共享其父级的上下文，而 *demux* 过滤器会复制其父级的上下文。

对于管道的脚本，这些**上下文变量**是其**全局变量**，这意味着这些变量始终可以从脚本任何位置访问，只要他们位于同一个脚本中。

经验丰富的程序员来说可能会感觉怪异。因为*全局变量*通常意味着它们是全局唯一的，始终只有一组。而在 Pipy 中，我们可以多组变量（也成为上下文），具体数量取决于端口管道的数量以及复制其父管道的子管道数量。拥有多组全局变量是 PipyJS 的一个关键特性，因为网络代理需要并行处理大量连接，每个连接都有其对外不可见的独立状态。

如果熟悉多线程编程的概念，可以把**上下文**理解成 [*TLS（线程本地存储）*](https://en.wikipedia.org/wiki/Thread-local_storage)。